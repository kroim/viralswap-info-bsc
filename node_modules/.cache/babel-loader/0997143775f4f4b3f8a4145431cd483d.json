{"ast":null,"code":"/**\r\n * Given a URI that may be ipfs, ipns, http, or https protocol, return the fetch-able http(s) URLs for the same content\r\n * @param uri to convert to fetch-able http url\r\n */\nfunction uriToHttp(uri) {\n  var _uri$match, _uri$match2;\n\n  const protocol = uri.split(':')[0].toLowerCase();\n\n  switch (protocol) {\n    case 'https':\n      return [uri];\n\n    case 'http':\n      return ['https' + uri.substr(4), uri];\n\n    case 'ipfs':\n      const hash = (_uri$match = uri.match(/^ipfs:(\\/\\/)?(.*)$/i)) === null || _uri$match === void 0 ? void 0 : _uri$match[2];\n      return [`https://cloudflare-ipfs.com/ipfs/${hash}/`, `https://ipfs.io/ipfs/${hash}/`];\n\n    case 'ipns':\n      const name = (_uri$match2 = uri.match(/^ipns:(\\/\\/)?(.*)$/i)) === null || _uri$match2 === void 0 ? void 0 : _uri$match2[2];\n      return [`https://cloudflare-ipfs.com/ipns/${name}/`, `https://ipfs.io/ipns/${name}/`];\n\n    default:\n      return [];\n  }\n}\n/**\r\n * Contains the logic for resolving a list URL to a validated token list\r\n * @param listUrl list url\r\n */\n\n\nexport default async function getTokenList(listUrl) {\n  const urls = uriToHttp(listUrl);\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i];\n    const isLast = i === urls.length - 1;\n    let response;\n\n    try {\n      response = await fetch(url);\n    } catch (error) {\n      console.debug('Failed to fetch list', listUrl, error);\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`);\n      continue;\n    }\n\n    if (!response.ok) {\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`);\n      continue;\n    }\n\n    const json = await response.json();\n    return json;\n  }\n\n  throw new Error('Unrecognized list URL protocol.');\n}","map":{"version":3,"sources":["B:/2021/1219_ViralCoin/work/NewSubgraph/pancake-info-v1/src/utils/tokenLists.ts"],"names":["uriToHttp","uri","protocol","split","toLowerCase","substr","hash","match","name","getTokenList","listUrl","urls","i","length","url","isLast","response","fetch","error","console","debug","Error","ok","json"],"mappings":"AAEA;;;;AAIA,SAASA,SAAT,CAAmBC,GAAnB,EAA0C;AAAA;;AACxC,QAAMC,QAAQ,GAAGD,GAAG,CAACE,KAAJ,CAAU,GAAV,EAAe,CAAf,EAAkBC,WAAlB,EAAjB;;AACA,UAAQF,QAAR;AACE,SAAK,OAAL;AACE,aAAO,CAACD,GAAD,CAAP;;AACF,SAAK,MAAL;AACE,aAAO,CAAC,UAAUA,GAAG,CAACI,MAAJ,CAAW,CAAX,CAAX,EAA0BJ,GAA1B,CAAP;;AACF,SAAK,MAAL;AACE,YAAMK,IAAI,iBAAGL,GAAG,CAACM,KAAJ,CAAU,qBAAV,CAAH,+CAAG,WAAmC,CAAnC,CAAb;AACA,aAAO,CAAE,oCAAmCD,IAAK,GAA1C,EAA+C,wBAAuBA,IAAK,GAA3E,CAAP;;AACF,SAAK,MAAL;AACE,YAAME,IAAI,kBAAGP,GAAG,CAACM,KAAJ,CAAU,qBAAV,CAAH,gDAAG,YAAmC,CAAnC,CAAb;AACA,aAAO,CAAE,oCAAmCC,IAAK,GAA1C,EAA+C,wBAAuBA,IAAK,GAA3E,CAAP;;AACF;AACE,aAAO,EAAP;AAZJ;AAcD;AAED;;;;;;AAIA,eAAe,eAAeC,YAAf,CAA4BC,OAA5B,EAAiE;AAC9E,QAAMC,IAAI,GAAGX,SAAS,CAACU,OAAD,CAAtB;;AACA,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,IAAI,CAACE,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AACpC,UAAME,GAAG,GAAGH,IAAI,CAACC,CAAD,CAAhB;AACA,UAAMG,MAAM,GAAGH,CAAC,KAAKD,IAAI,CAACE,MAAL,GAAc,CAAnC;AACA,QAAIG,QAAJ;;AACA,QAAI;AACFA,MAAAA,QAAQ,GAAG,MAAMC,KAAK,CAACH,GAAD,CAAtB;AACD,KAFD,CAEE,OAAOI,KAAP,EAAc;AACdC,MAAAA,OAAO,CAACC,KAAR,CAAc,sBAAd,EAAsCV,OAAtC,EAA+CQ,KAA/C;AACA,UAAIH,MAAJ,EAAY,MAAM,IAAIM,KAAJ,CAAW,2BAA0BX,OAAQ,EAA7C,CAAN;AACZ;AACD;;AAED,QAAI,CAACM,QAAQ,CAACM,EAAd,EAAkB;AAChB,UAAIP,MAAJ,EAAY,MAAM,IAAIM,KAAJ,CAAW,2BAA0BX,OAAQ,EAA7C,CAAN;AACZ;AACD;;AAED,UAAMa,IAAI,GAAG,MAAMP,QAAQ,CAACO,IAAT,EAAnB;AACA,WAAOA,IAAP;AACD;;AACD,QAAM,IAAIF,KAAJ,CAAU,iCAAV,CAAN;AACD","sourcesContent":["import { TokenList } from '@uniswap/token-lists'\r\n\r\n/**\r\n * Given a URI that may be ipfs, ipns, http, or https protocol, return the fetch-able http(s) URLs for the same content\r\n * @param uri to convert to fetch-able http url\r\n */\r\nfunction uriToHttp(uri: string): string[] {\r\n  const protocol = uri.split(':')[0].toLowerCase()\r\n  switch (protocol) {\r\n    case 'https':\r\n      return [uri]\r\n    case 'http':\r\n      return ['https' + uri.substr(4), uri]\r\n    case 'ipfs':\r\n      const hash = uri.match(/^ipfs:(\\/\\/)?(.*)$/i)?.[2]\r\n      return [`https://cloudflare-ipfs.com/ipfs/${hash}/`, `https://ipfs.io/ipfs/${hash}/`]\r\n    case 'ipns':\r\n      const name = uri.match(/^ipns:(\\/\\/)?(.*)$/i)?.[2]\r\n      return [`https://cloudflare-ipfs.com/ipns/${name}/`, `https://ipfs.io/ipns/${name}/`]\r\n    default:\r\n      return []\r\n  }\r\n}\r\n\r\n/**\r\n * Contains the logic for resolving a list URL to a validated token list\r\n * @param listUrl list url\r\n */\r\nexport default async function getTokenList(listUrl: string): Promise<TokenList> {\r\n  const urls = uriToHttp(listUrl)\r\n  for (let i = 0; i < urls.length; i++) {\r\n    const url = urls[i]\r\n    const isLast = i === urls.length - 1\r\n    let response\r\n    try {\r\n      response = await fetch(url)\r\n    } catch (error) {\r\n      console.debug('Failed to fetch list', listUrl, error)\r\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`)\r\n      continue\r\n    }\r\n\r\n    if (!response.ok) {\r\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`)\r\n      continue\r\n    }\r\n\r\n    const json = await response.json()\r\n    return json\r\n  }\r\n  throw new Error('Unrecognized list URL protocol.')\r\n}\r\n"]},"metadata":{},"sourceType":"module"}